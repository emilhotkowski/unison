-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package unison-sqlite
@version 0.0.0

module Unison.Sqlite.Connection.Internal

-- | A <i>non-thread safe</i> connection to a SQLite database.
data Connection
Connection :: String -> FilePath -> Connection -> Connection
[$sel:name:Connection] :: Connection -> String
[$sel:file:Connection] :: Connection -> FilePath
[$sel:conn:Connection] :: Connection -> Connection
instance GHC.Show.Show Unison.Sqlite.Connection.Internal.Connection

module Unison.Sqlite.Connection

-- | A <i>non-thread safe</i> connection to a SQLite database.
data Connection
Connection :: String -> FilePath -> Connection -> Connection
[$sel:name:Connection] :: Connection -> String
[$sel:file:Connection] :: Connection -> FilePath
[$sel:conn:Connection] :: Connection -> Connection

-- | Perform an action with a connection to a SQLite database.
--   
--   Note: the connection is created with <tt>PRAGMA foreign_keys = ON</tt>
--   automatically, to work around the fact that SQLite does not
--   automatically enforce foreign key integrity, because it elected to
--   maintain backwards compatibility with code that was written before the
--   foreign key integrity feature was implemented.
withConnection :: MonadUnliftIO m => String -> FilePath -> (Connection -> m a) -> m a
execute :: ToRow a => Connection -> Sql -> a -> IO ()
executeMany :: ToRow a => Connection -> Sql -> [a] -> IO ()
execute_ :: Connection -> Sql -> IO ()
queryStreamRow :: (FromRow b, ToRow a) => Connection -> Sql -> a -> (IO (Maybe b) -> IO r) -> IO r
queryStreamCol :: forall a b r. (FromField b, ToRow a) => Connection -> Sql -> a -> (IO (Maybe b) -> IO r) -> IO r
queryListRow :: (FromRow b, ToRow a) => Connection -> Sql -> a -> IO [b]
queryListCol :: forall a b. (FromField b, ToRow a) => Connection -> Sql -> a -> IO [b]
queryMaybeRow :: (ToRow a, FromRow b) => Connection -> Sql -> a -> IO (Maybe b)
queryMaybeCol :: forall a b. (ToRow a, FromField b) => Connection -> Sql -> a -> IO (Maybe b)
queryOneRow :: (FromRow b, ToRow a) => Connection -> Sql -> a -> IO b
queryOneCol :: forall a b. (FromField b, ToRow a) => Connection -> Sql -> a -> IO b
queryListRowCheck :: (FromRow b, ToRow a, SqliteExceptionReason e) => Connection -> Sql -> a -> ([b] -> Either e r) -> IO r
queryListColCheck :: forall a b e r. (FromField b, ToRow a, SqliteExceptionReason e) => Connection -> Sql -> a -> ([b] -> Either e r) -> IO r
queryMaybeRowCheck :: (FromRow b, ToRow a, SqliteExceptionReason e) => Connection -> Sql -> a -> (b -> Either e r) -> IO (Maybe r)
queryMaybeColCheck :: forall a b e r. (FromField b, ToRow a, SqliteExceptionReason e) => Connection -> Sql -> a -> (b -> Either e r) -> IO (Maybe r)
queryOneRowCheck :: (FromRow b, ToRow a, SqliteExceptionReason e) => Connection -> Sql -> a -> (b -> Either e r) -> IO r
queryOneColCheck :: forall a b e r. (FromField b, ToRow a, SqliteExceptionReason e) => Connection -> Sql -> a -> (b -> Either e r) -> IO r
queryListRow_ :: FromRow a => Connection -> Sql -> IO [a]
queryListCol_ :: forall a. FromField a => Connection -> Sql -> IO [a]
queryMaybeRow_ :: FromRow a => Connection -> Sql -> IO (Maybe a)
queryMaybeCol_ :: forall a. FromField a => Connection -> Sql -> IO (Maybe a)
queryOneRow_ :: FromRow a => Connection -> Sql -> IO a
queryOneCol_ :: forall a. FromField a => Connection -> Sql -> IO a
queryListRowCheck_ :: (FromRow a, SqliteExceptionReason e) => Connection -> Sql -> ([a] -> Either e r) -> IO r
queryListColCheck_ :: forall a e r. (FromField a, SqliteExceptionReason e) => Connection -> Sql -> ([a] -> Either e r) -> IO r
queryMaybeRowCheck_ :: (FromRow a, SqliteExceptionReason e) => Connection -> Sql -> (a -> Either e r) -> IO (Maybe r)
queryMaybeColCheck_ :: forall a e r. (FromField a, SqliteExceptionReason e) => Connection -> Sql -> (a -> Either e r) -> IO (Maybe r)
queryOneRowCheck_ :: (FromRow a, SqliteExceptionReason e) => Connection -> Sql -> (a -> Either e r) -> IO r
queryOneColCheck_ :: forall a e r. (FromField a, SqliteExceptionReason e) => Connection -> Sql -> (a -> Either e r) -> IO r

-- | <pre>
--   VACUUM
--   </pre>
vacuum :: Connection -> IO ()

-- | <pre>
--   VACUUM INTO
--   </pre>
vacuumInto :: Connection -> Text -> IO ()

-- | <pre>
--   BEGIN
--   </pre>
begin :: Connection -> IO ()

-- | <pre>
--   BEGIN IMMEDIATE
--   </pre>
beginImmediate :: Connection -> IO ()

-- | <pre>
--   COMMIT
--   </pre>
commit :: Connection -> IO ()

-- | <pre>
--   ROLLBACK
--   </pre>
rollback :: Connection -> IO ()

-- | Perform an action within a named savepoint. The action is provided a
--   rollback action.
withSavepoint :: MonadUnliftIO m => Connection -> Text -> (m () -> m a) -> m a
withSavepointIO :: Connection -> Text -> (IO () -> IO a) -> IO a

-- | <pre>
--   SAVEPOINT
--   </pre>
savepoint :: Connection -> Text -> IO ()

-- | <pre>
--   ROLLBACK TO
--   </pre>
rollbackTo :: Connection -> Text -> IO ()

-- | <pre>
--   RELEASE
--   </pre>
release :: Connection -> Text -> IO ()

-- | A query was expected to return exactly one row, but it did not. The
--   exception carries a string representation of the rows that were
--   actually returned.
newtype ExpectedAtMostOneRowException
ExpectedAtMostOneRowException :: String -> ExpectedAtMostOneRowException
[$sel:rows:ExpectedAtMostOneRowException] :: ExpectedAtMostOneRowException -> String

-- | A query was expected to return exactly one row, but it did not. The
--   exception carries a string representation of the rows that were
--   actually returned.
newtype ExpectedExactlyOneRowException
ExpectedExactlyOneRowException :: String -> ExpectedExactlyOneRowException
[$sel:rows:ExpectedExactlyOneRowException] :: ExpectedExactlyOneRowException -> String
instance Unison.Sqlite.Exception.SqliteExceptionReason Unison.Sqlite.Connection.ExpectedExactlyOneRowException
instance GHC.Show.Show Unison.Sqlite.Connection.ExpectedExactlyOneRowException
instance Unison.Sqlite.Exception.SqliteExceptionReason Unison.Sqlite.Connection.ExpectedAtMostOneRowException
instance GHC.Show.Show Unison.Sqlite.Connection.ExpectedAtMostOneRowException
instance GHC.Show.Show Unison.Sqlite.Connection.Query

module Unison.Sqlite.Transaction
data Transaction a

-- | Run a transaction on the given connection.
runTransaction :: MonadIO m => Connection -> Transaction a -> m a

-- | Run a transaction that is known to only perform reads.
--   
--   The action is provided a function that peels off the
--   <a>Transaction</a> newtype without sending the corresponding
--   BEGIN/COMMIT statements.
--   
--   The transaction is never retried, so it is (more) safe to interleave
--   arbitrary IO actions. If the transaction does attempt a write and gets
--   SQLITE_BUSY, it's your fault!
runReadOnlyTransaction :: MonadUnliftIO m => Connection -> ((forall x. Transaction x -> m x) -> m a) -> m a

-- | Run a transaction that is known to perform at least one write.
--   
--   The action is provided a function that peels off the
--   <a>Transaction</a> newtype without sending the corresponding
--   BEGIN/COMMIT statements.
--   
--   The transaction is never retried, so it is (more) safe to interleave
--   arbitrary IO actions.
runWriteTransaction :: MonadUnliftIO m => Connection -> ((forall x. Transaction x -> m x) -> m a) -> m a

-- | Unwrap the transaction newtype, throwing away the sending of
--   BEGIN/COMMIT + automatic retry.
unsafeUnTransaction :: Transaction a -> Connection -> IO a

-- | Perform an atomic sub-computation within a transaction; if it returns
--   <a>Left</a>, it's rolled back.
savepoint :: Transaction (Either a a) -> Transaction a

-- | Perform IO inside a transaction, which should be idempotent, because
--   it may be run more than once if the transaction needs to retry.
--   
--   <i>Warning</i>: attempting to run a transaction inside a transaction
--   will cause an exception!
unsafeIO :: IO a -> Transaction a
execute :: ToRow a => Sql -> a -> Transaction ()
executeMany :: ToRow a => Sql -> [a] -> Transaction ()
execute_ :: Sql -> Transaction ()
queryStreamRow :: (FromRow a, ToRow b) => Sql -> b -> (Transaction (Maybe a) -> Transaction r) -> Transaction r
queryStreamCol :: forall a b r. (FromField a, ToRow b) => Sql -> b -> (Transaction (Maybe a) -> Transaction r) -> Transaction r
queryListRow :: (FromRow a, ToRow b) => Sql -> b -> Transaction [a]
queryListCol :: (FromField a, ToRow b) => Sql -> b -> Transaction [a]
queryMaybeRow :: (FromRow a, ToRow b) => Sql -> b -> Transaction (Maybe a)
queryMaybeCol :: (FromField a, ToRow b) => Sql -> b -> Transaction (Maybe a)
queryOneRow :: (FromRow b, ToRow a) => Sql -> a -> Transaction b
queryOneCol :: (FromField b, ToRow a) => Sql -> a -> Transaction b
queryListRowCheck :: (FromRow b, ToRow a, SqliteExceptionReason e) => Sql -> a -> ([b] -> Either e r) -> Transaction r
queryListColCheck :: (FromField b, ToRow a, SqliteExceptionReason e) => Sql -> a -> ([b] -> Either e r) -> Transaction r
queryMaybeRowCheck :: (FromRow b, ToRow a, SqliteExceptionReason e) => Sql -> a -> (b -> Either e r) -> Transaction (Maybe r)
queryMaybeColCheck :: (FromField b, ToRow a, SqliteExceptionReason e) => Sql -> a -> (b -> Either e r) -> Transaction (Maybe r)
queryOneRowCheck :: (FromRow b, ToRow a, SqliteExceptionReason e) => Sql -> a -> (b -> Either e r) -> Transaction r
queryOneColCheck :: (FromField b, ToRow a, SqliteExceptionReason e) => Sql -> a -> (b -> Either e r) -> Transaction r
queryListRow_ :: FromRow a => Sql -> Transaction [a]
queryListCol_ :: FromField a => Sql -> Transaction [a]
queryMaybeRow_ :: FromRow a => Sql -> Transaction (Maybe a)
queryMaybeCol_ :: FromField a => Sql -> Transaction (Maybe a)
queryOneRow_ :: FromRow a => Sql -> Transaction a
queryOneCol_ :: FromField a => Sql -> Transaction a
queryListRowCheck_ :: (FromRow a, SqliteExceptionReason e) => Sql -> ([a] -> Either e r) -> Transaction r
queryListColCheck_ :: (FromField a, SqliteExceptionReason e) => Sql -> ([a] -> Either e r) -> Transaction r
queryMaybeRowCheck_ :: (FromRow a, SqliteExceptionReason e) => Sql -> (a -> Either e r) -> Transaction (Maybe r)
queryMaybeColCheck_ :: (FromField a, SqliteExceptionReason e) => Sql -> (a -> Either e r) -> Transaction (Maybe r)
queryOneRowCheck_ :: (FromRow a, SqliteExceptionReason e) => Sql -> (a -> Either e r) -> Transaction r
queryOneColCheck_ :: (FromField a, SqliteExceptionReason e) => Sql -> (a -> Either e r) -> Transaction r
instance GHC.Base.Monad Unison.Sqlite.Transaction.Transaction
instance GHC.Base.Functor Unison.Sqlite.Transaction.Transaction
instance GHC.Base.Applicative Unison.Sqlite.Transaction.Transaction


-- | The Unison monorepo interface to SQLite.
--   
--   This module provides a high(-er) level interface to SQLite than the
--   <tt>sqlite-simple</tt> library, which it wraps. Code that interacts
--   with SQLite in this monorepo should use this interface, rather than
--   <tt>sqlite-simple</tt> or <tt>direct-sqlite</tt> directly.
--   
--   Three variants of the main query interface are provided:
--   
--   <ul>
--   <li><a>Unison.Sqlite.Connection</a> provides an interface in
--   <tt>IO</tt>, which takes the <a>Connection</a> argument as an explicit
--   argument.</li>
--   <li><a>Unison.Sqlite.Transaction</a> provides a safer interface that
--   executes queries in transactions, with automatic retries on
--   <tt>SQLITE_BUSY</tt> due to concurrent writers.</li>
--   </ul>
module Unison.Sqlite

-- | A <i>non-thread safe</i> connection to a SQLite database.
data Connection

-- | Perform an action with a connection to a SQLite database.
--   
--   Note: the connection is created with <tt>PRAGMA foreign_keys = ON</tt>
--   automatically, to work around the fact that SQLite does not
--   automatically enforce foreign key integrity, because it elected to
--   maintain backwards compatibility with code that was written before the
--   foreign key integrity feature was implemented.
withConnection :: MonadUnliftIO m => String -> FilePath -> (Connection -> m a) -> m a
data Transaction a

-- | Run a transaction on the given connection.
runTransaction :: MonadIO m => Connection -> Transaction a -> m a

-- | Run a transaction that is known to only perform reads.
--   
--   The action is provided a function that peels off the
--   <a>Transaction</a> newtype without sending the corresponding
--   BEGIN/COMMIT statements.
--   
--   The transaction is never retried, so it is (more) safe to interleave
--   arbitrary IO actions. If the transaction does attempt a write and gets
--   SQLITE_BUSY, it's your fault!
runReadOnlyTransaction :: MonadUnliftIO m => Connection -> ((forall x. Transaction x -> m x) -> m a) -> m a

-- | Run a transaction that is known to perform at least one write.
--   
--   The action is provided a function that peels off the
--   <a>Transaction</a> newtype without sending the corresponding
--   BEGIN/COMMIT statements.
--   
--   The transaction is never retried, so it is (more) safe to interleave
--   arbitrary IO actions.
runWriteTransaction :: MonadUnliftIO m => Connection -> ((forall x. Transaction x -> m x) -> m a) -> m a

-- | Unwrap the transaction newtype, throwing away the sending of
--   BEGIN/COMMIT + automatic retry.
unsafeUnTransaction :: Transaction a -> Connection -> IO a

-- | Perform an atomic sub-computation within a transaction; if it returns
--   <a>Left</a>, it's rolled back.
savepoint :: Transaction (Either a a) -> Transaction a

-- | Perform IO inside a transaction, which should be idempotent, because
--   it may be run more than once if the transaction needs to retry.
--   
--   <i>Warning</i>: attempting to run a transaction inside a transaction
--   will cause an exception!
unsafeIO :: IO a -> Transaction a

-- | A SQL snippet.
newtype Sql
Sql :: Text -> Sql
execute :: ToRow a => Sql -> a -> Transaction ()
executeMany :: ToRow a => Sql -> [a] -> Transaction ()
execute_ :: Sql -> Transaction ()
queryStreamRow :: (FromRow a, ToRow b) => Sql -> b -> (Transaction (Maybe a) -> Transaction r) -> Transaction r
queryStreamCol :: forall a b r. (FromField a, ToRow b) => Sql -> b -> (Transaction (Maybe a) -> Transaction r) -> Transaction r
queryListRow :: (FromRow a, ToRow b) => Sql -> b -> Transaction [a]
queryListCol :: (FromField a, ToRow b) => Sql -> b -> Transaction [a]
queryMaybeRow :: (FromRow a, ToRow b) => Sql -> b -> Transaction (Maybe a)
queryMaybeCol :: (FromField a, ToRow b) => Sql -> b -> Transaction (Maybe a)
queryOneRow :: (FromRow b, ToRow a) => Sql -> a -> Transaction b
queryOneCol :: (FromField b, ToRow a) => Sql -> a -> Transaction b
queryListRowCheck :: (FromRow b, ToRow a, SqliteExceptionReason e) => Sql -> a -> ([b] -> Either e r) -> Transaction r
queryListColCheck :: (FromField b, ToRow a, SqliteExceptionReason e) => Sql -> a -> ([b] -> Either e r) -> Transaction r
queryMaybeRowCheck :: (FromRow b, ToRow a, SqliteExceptionReason e) => Sql -> a -> (b -> Either e r) -> Transaction (Maybe r)
queryMaybeColCheck :: (FromField b, ToRow a, SqliteExceptionReason e) => Sql -> a -> (b -> Either e r) -> Transaction (Maybe r)
queryOneRowCheck :: (FromRow b, ToRow a, SqliteExceptionReason e) => Sql -> a -> (b -> Either e r) -> Transaction r
queryOneColCheck :: (FromField b, ToRow a, SqliteExceptionReason e) => Sql -> a -> (b -> Either e r) -> Transaction r
queryListRow_ :: FromRow a => Sql -> Transaction [a]
queryListCol_ :: FromField a => Sql -> Transaction [a]
queryMaybeRow_ :: FromRow a => Sql -> Transaction (Maybe a)
queryMaybeCol_ :: FromField a => Sql -> Transaction (Maybe a)
queryOneRow_ :: FromRow a => Sql -> Transaction a
queryOneCol_ :: FromField a => Sql -> Transaction a
queryListRowCheck_ :: (FromRow a, SqliteExceptionReason e) => Sql -> ([a] -> Either e r) -> Transaction r
queryListColCheck_ :: (FromField a, SqliteExceptionReason e) => Sql -> ([a] -> Either e r) -> Transaction r
queryMaybeRowCheck_ :: (FromRow a, SqliteExceptionReason e) => Sql -> (a -> Either e r) -> Transaction (Maybe r)
queryMaybeColCheck_ :: (FromField a, SqliteExceptionReason e) => Sql -> (a -> Either e r) -> Transaction (Maybe r)
queryOneRowCheck_ :: (FromRow a, SqliteExceptionReason e) => Sql -> (a -> Either e r) -> Transaction r
queryOneColCheck_ :: (FromField a, SqliteExceptionReason e) => Sql -> (a -> Either e r) -> Transaction r
newtype DataVersion
DataVersion :: Int64 -> DataVersion
getDataVersion :: Transaction DataVersion

-- | <a>https://www.sqlite.org/pragma.html#pragma_journal_mode</a>
data JournalMode
JournalMode'DELETE :: JournalMode
JournalMode'TRUNCATE :: JournalMode
JournalMode'PERSIST :: JournalMode
JournalMode'MEMORY :: JournalMode
JournalMode'WAL :: JournalMode
JournalMode'OFF :: JournalMode
trySetJournalMode :: MonadIO m => Connection -> JournalMode -> m ()

-- | <pre>
--   VACUUM
--   </pre>
vacuum :: Connection -> IO ()

-- | <pre>
--   VACUUM INTO
--   </pre>
vacuumInto :: Connection -> Text -> IO ()

-- | The root exception for all exceptions thrown by this library.
--   
--   <pre>
--   SomeException (from base)
--     └── SomeSqliteException
--           └── SqliteConnectException
--           └── SqliteQueryException
--   </pre>
--   
--   A <tt>SomeSqliteException</tt> should not be inspected or used for
--   control flow when run in a trusted environment, where the database can
--   be assumed to be uncorrupt. Rather, wherever possible, the user of
--   this library should write code that is guaranteed not to throw
--   exceptions, by checking the necessary preconditions first. If that is
--   not possible, it should be considered a bug in this library.
--   
--   When actions are run on an untrusted codebase, e.g. one downloaded
--   from a remote server, it is sufficient to catch just one exception
--   type, <tt>SomeSqliteException</tt>.
data SomeSqliteException
SomeSqliteException :: e -> SomeSqliteException
isCantOpenException :: SomeSqliteException -> Bool

-- | An exception thrown during establishing a connection.
data SqliteConnectException
SqliteConnectException :: ThreadId -> String -> FilePath -> SQLError -> SqliteConnectException
[$sel:threadId:SqliteConnectException] :: SqliteConnectException -> ThreadId
[$sel:name:SqliteConnectException] :: SqliteConnectException -> String
[$sel:file:SqliteConnectException] :: SqliteConnectException -> FilePath
[$sel:exception:SqliteConnectException] :: SqliteConnectException -> SQLError

-- | A <tt>SqliteQueryException</tt> represents an exception thrown during
--   processing a query, paired with some context that resulted in the
--   exception.
--   
--   A <tt>SqliteQueryException</tt> may result from a number of different
--   conditions:
--   
--   <ul>
--   <li>The underlying sqlite library threw an exception.</li>
--   <li>A postcondition violation of a function like <a>queryMaybeRow</a>,
--   which asserts that the resulting relation will have certain number of
--   rows,</li>
--   <li>A postcondition violation of a function like
--   <a>queryListRowCheck</a>, which takes a user-defined check as an
--   argument.</li>
--   </ul>
--   
--   A <tt>SqliteQueryException</tt> should not be inspected or used for
--   control flow when run in a trusted environment, where the database can
--   be assumed to be uncorrupt. Rather, wherever possible, the user of
--   this library should write code that is guaranteed not to throw
--   exceptions, by checking the necessary preconditions first. If that is
--   not possible, it should be considered a bug in this library.
--   
--   When actions are run on an untrusted codebase, e.g. one downloaded
--   from a remote server, it is sufficient to catch just one exception
--   type, <tt>SqliteQueryException</tt>.
data SqliteQueryException
SqliteQueryException :: Sql -> String -> SomeSqliteExceptionReason -> [String] -> Connection -> ThreadId -> SqliteQueryException
[$sel:sql:SqliteQueryException] :: SqliteQueryException -> Sql
[$sel:params:SqliteQueryException] :: SqliteQueryException -> String

-- | The inner exception. It is intentionally not <a>SomeException</a>, so
--   that calling code cannot accidentally <a>throwIO</a> domain-specific
--   exception types, but must instead use a <tt>*Check</tt> query variant.
[$sel:exception:SqliteQueryException] :: SqliteQueryException -> SomeSqliteExceptionReason
[$sel:callStack:SqliteQueryException] :: SqliteQueryException -> [String]
[$sel:connection:SqliteQueryException] :: SqliteQueryException -> Connection
[$sel:threadId:SqliteQueryException] :: SqliteQueryException -> ThreadId

-- | A type that is intended to be used as additional context for a
--   sqlite-related exception.
class (Show e, Typeable e) => SqliteExceptionReason e
data SomeSqliteExceptionReason
SomeSqliteExceptionReason :: e -> SomeSqliteExceptionReason

-- | A query was expected to return exactly one row, but it did not. The
--   exception carries a string representation of the rows that were
--   actually returned.
newtype ExpectedAtMostOneRowException
ExpectedAtMostOneRowException :: String -> ExpectedAtMostOneRowException
[$sel:rows:ExpectedAtMostOneRowException] :: ExpectedAtMostOneRowException -> String

-- | A query was expected to return exactly one row, but it did not. The
--   exception carries a string representation of the rows that were
--   actually returned.
newtype ExpectedExactlyOneRowException
ExpectedExactlyOneRowException :: String -> ExpectedExactlyOneRowException
[$sel:rows:ExpectedExactlyOneRowException] :: ExpectedExactlyOneRowException -> String
data SetJournalModeException
SetJournalModeException :: JournalMode -> JournalMode -> SetJournalModeException
[$sel:currentJournalMode:SetJournalModeException] :: SetJournalModeException -> JournalMode
[$sel:couldntSetTo:SetJournalModeException] :: SetJournalModeException -> JournalMode
field :: FromField a => RowParser a

-- | A composite type to parse your custom data structures without having
--   to define dummy newtype wrappers every time.
--   
--   <pre>
--   instance FromRow MyData where ...
--   </pre>
--   
--   <pre>
--   instance FromRow MyData2 where ...
--   </pre>
--   
--   then I can do the following for free:
--   
--   <pre>
--   res &lt;- query' c "..."
--   forM res $ \(MyData{..} :. MyData2{..}) -&gt; do
--     ....
--   </pre>
data h :. t
(:.) :: h -> t -> (:.) h t
infixr 3 :.
infixr 3 :.

-- | A type that may be converted from a SQL type.
class FromField a

-- | Convert a SQL value to a Haskell value.
--   
--   Returns a list of exceptions if the conversion fails. In the case of
--   library instances, this will usually be a single <a>ResultError</a>,
--   but may be a <tt>UnicodeException</tt>.
--   
--   Implementations of <a>fromField</a> should not retain any references
--   to the <a>Field</a> nor the <a>ByteString</a> arguments after the
--   result has been evaluated to WHNF. Such a reference causes the entire
--   <tt>LibPQ.<a>Result</a></tt> to be retained.
--   
--   For example, the instance for <a>ByteString</a> uses <a>copy</a> to
--   avoid such a reference, and that using bytestring functions such as
--   <a>drop</a> and <a>takeWhile</a> alone will also trigger this memory
--   leak.
fromField :: FromField a => FieldParser a

-- | A collection type that can be converted from a sequence of fields.
--   Instances are provided for tuples up to 10 elements and lists of any
--   length.
--   
--   Note that instances can defined outside of sqlite-simple, which is
--   often useful. For example, here's an instance for a user-defined pair:
--   
--   @data User = User { name :: String, fileQuota :: Int }
--   
--   instance <a>FromRow</a> User where fromRow = User &lt;$&gt;
--   <a>field</a> &lt;*&gt; <a>field</a> @
--   
--   The number of calls to <a>field</a> must match the number of fields
--   returned in a single row of the query result. Otherwise, a
--   <a>ConversionFailed</a> exception will be thrown.
--   
--   Note the caveats associated with user-defined implementations of
--   <a>fromRow</a>.
class FromRow a
fromRow :: FromRow a => RowParser a
data RowParser a
data SQLData
SQLInteger :: !Int64 -> SQLData
SQLFloat :: !Double -> SQLData
SQLText :: !Text -> SQLData
SQLBlob :: !ByteString -> SQLData
SQLNull :: SQLData

-- | A type that may be used as a single parameter to a SQL query.
class ToField a

-- | Prepare a value for substitution into a query string.
toField :: ToField a => a -> SQLData

-- | A collection type that can be turned into a list of <a>SQLData</a>
--   elements.
class ToRow a

-- | <a>ToField</a> a collection of values.
toRow :: ToRow a => a -> [SQLData]

-- | The 1-tuple type or single-value "collection".
--   
--   This type is structurally equivalent to the <a>Identity</a> type, but
--   its intent is more about serving as the anonymous 1-tuple type missing
--   from Haskell for attaching typeclass instances.
--   
--   Parameter usage example:
--   
--   <pre>
--   encodeSomething (<a>Only</a> (42::Int))
--   </pre>
--   
--   Result usage example:
--   
--   <pre>
--   xs &lt;- decodeSomething
--   forM_ xs $ \(<a>Only</a> id) -&gt; {- ... -}
--   </pre>
newtype Only a
Only :: a -> Only a
[fromOnly] :: Only a -> a
